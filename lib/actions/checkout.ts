"use server"

import { createClient } from "@/lib/supabase/server"
import { createAdminClient } from "@/lib/supabase/admin"
import { sendStaffBookingAlert } from "@/lib/email"

interface CreateBookingInput {
  checkIn: string
  checkOut: string
  guestsCount: number
  rooms: { roomId: string; bedId?: string; pricePerNight: number }[]
  services?: {
    serviceId: string
    quantity: number
    priceAtBooking: number
    scheduledDate?: string
  }[]
  specialRequests?: string
  guestInfo: {
    email: string
    fullName: string
    phone?: string
    nationality?: string
  }
}

interface CreateBookingResult {
  bookingId: string
  bookingReference: string
  totalAmount: number
}

/**
 * Create a booking with pending_payment status.
 * The guest will then pay via Tab.travel using the booking_reference.
 * Admin confirms payment manually after receiving Tab notification.
 */
export async function createBookingWithCheckout(
  input: CreateBookingInput
): Promise<CreateBookingResult> {
  const supabase = createAdminClient()
  const authClient = await createClient()

  // Get authenticated user if exists
  const { data: authUser } = await authClient.auth.getUser()
  let userId = authUser?.user?.id

  if (!userId) {
    const { data: existingUser } = await supabase
      .from("users")
      .select("id")
      .eq("email", input.guestInfo.email)
      .maybeSingle()

    if (existingUser) {
      userId = existingUser.id
    } else {
      // Create new guest user (using admin client)
      const { data: newUser, error: userError } = await supabase
        .from("users")
        .insert({
          email: input.guestInfo.email,
          full_name: input.guestInfo.fullName,
          phone: input.guestInfo.phone,
          nationality: input.guestInfo.nationality,
        })
        .select("id")
        .single()

      if (userError) {
        throw new Error("Failed to create user")
      }
      userId = newUser.id
    }
  }

  // Calculate totals
  const nights = Math.ceil(
    (new Date(input.checkOut).getTime() - new Date(input.checkIn).getTime()) /
      (1000 * 60 * 60 * 24)
  )

  let roomsTotal = 0
  input.rooms.forEach((room) => {
    roomsTotal += room.pricePerNight * nights
  })

  let servicesTotal = 0
  input.services?.forEach((service) => {
    servicesTotal += service.priceAtBooking * service.quantity
  })

  const subtotal = roomsTotal + servicesTotal
  const tax = subtotal * 0.13 // Costa Rica IVA
  const totalAmount = subtotal + tax

  // Create booking in database (booking_reference is auto-generated by DB trigger)
  const { data: booking, error: bookingError } = await supabase
    .from("bookings")
    .insert({
      user_id: userId,
      check_in: input.checkIn,
      check_out: input.checkOut,
      guests_count: input.guestsCount,
      total_amount: totalAmount,
      special_requests: input.specialRequests,
      source: "direct",
      status: "pending_payment",
      payment_status: "pending",
    })
    .select("id, booking_reference, total_amount")
    .single()

  if (bookingError) {
    throw new Error("Failed to create booking")
  }

  // Insert booking rooms
  const bookingRoomsData = input.rooms.map((room) => ({
    booking_id: booking.id,
    room_id: room.roomId,
    bed_id: room.bedId || null,
    price_per_night: room.pricePerNight,
  }))

  const { error: roomsError } = await supabase
    .from("booking_rooms")
    .insert(bookingRoomsData)

  if (roomsError) {
    // Rollback: delete the booking if rooms fail
    await supabase.from("bookings").delete().eq("id", booking.id)
    throw new Error("Failed to create booking rooms")
  }

  // Insert booking services
  if (input.services && input.services.length > 0) {
    const bookingServicesData = input.services.map((service) => ({
      booking_id: booking.id,
      service_id: service.serviceId,
      quantity: service.quantity,
      price_at_booking: service.priceAtBooking,
      scheduled_date: service.scheduledDate || null,
    }))

    const { error: servicesError } = await supabase
      .from("booking_services")
      .insert(bookingServicesData)

    if (servicesError) {
      // Don't fail the entire booking if services fail
      // The booking is still valid without extras
    }
  }

  // Create check-in data record
  await supabase.from("check_in_data").insert({
    booking_id: booking.id,
    terms_accepted: false,
  })

  // Fetch room names for staff alert email
  const roomNames = await Promise.all(
    input.rooms.map(async (room) => {
      const { data } = await supabase
        .from("rooms")
        .select("name")
        .eq("id", room.roomId)
        .single()
      return data?.name || "Room"
    })
  )

  // Send staff alert (fire and forget - don't block the response)
  sendStaffBookingAlert({
    bookingId: booking.booking_reference || booking.id.slice(0, 8),
    guestName: input.guestInfo.fullName,
    guestEmail: input.guestInfo.email,
    checkIn: input.checkIn,
    checkOut: input.checkOut,
    roomNames,
    total: totalAmount,
    source: "direct",
  }).catch(() => {
    // Silently fail - email is not critical
  })

  return {
    bookingId: booking.id,
    bookingReference: booking.booking_reference || booking.id.slice(0, 8).toUpperCase(),
    totalAmount,
  }
}
